---
title: "Testing"
execute: 
  echo: True
author: Cath Riddoch
format:
  html:
    embed-resources: true
editor: 
  markdown: 
    wrap: 72
---

## What are Unit tests

Unit tests are just a way to formalise, automate and speed up that
checking process.

Individual components are tested in isolation to verify their
correctness. These components often the smallest testable parts of an
application or pipeline so could be functions, methods or classes.

## Why use them

Ensures individual pieces of code work as intended. - Does your function
always do what you think it does?

-   Helps catch bugs early before they become bigger issues

-   Helps during refactoring of code or during the initial development
    of code "TDD"

## How to use them

Code I ran in workshop this is here in case people missed it. Don't run
this code inside Quarto. If you want to replicate what I did then copy
the code and paste it into console to run.

```{r}
# makes a package
usethis::create_package("path to where you want the package")

# makes a function
usethis::use_r("add_one")

# makes a test for the function 
usethis::use_test()
```

I then loaded devtools and the package by running the following code in
the console.

```{r}
library(devtools)
load_all()
```

If I had loaded devtools earlier I wouldn't need to add the usethis:: in
front of use_test and use_r.

Each time you make a change to code inside a package you need to re-load
the package. I use ctrl +shift +L.

The test function I wrote inside the test created.

```{r}
test_that("add_one adds one", {

  # arrange
  test_data<- 5:10

  # action
  result<- add_one(test_data)

  # assert (can have multiple rows here checking different things)
  expect_equal(result, 6:11)
  expect_true(is.numeric(result))
})

# can also have more than one testthat() I usually like a new testthat if I re-run the function with different input. 
```

Note that testthat tests must live in files below tests/testthat/ and
the files must begin with "test"

The test filename is displayed in the testthat output so with careful
naming provides helpful context.

A test file holds one or more test_that() tests Each test describes what
it tis testing eg "multiplication works" Each test has one or more
expectations eg expect_equal(2 \* 2, 4)

## What makes a good test?

Ideally tests should be self-sufficient and self-contained. It is more
important to be obvious than DRY. A range of values and edge cases
should be included

## other assertions

expect_equal has some numeric tolerance If you want exact equivalence
use expect_identical Also have:

expect_null()

expect_true()

expect_false()

expect_error()

expect_warning()

## running tests

click the button

Ctrl + Shift + T

devtools::test()

## Scope

every testthat test has its own execution environment need to think
about that when using functions from packages or running code globally

## Feedback

I would like feedback on the workshop series and requested that this be
done by submitting a pull request to the training repository. I didn't
demonstrate how to do that but any google search will give you
instructions for how to submit a pull request. Please try. I don't care
if you break the repo and you will gain experience and skills that are
needed for working with code collaboratively.

<https://jarv.is/notes/how-to-pull-request-fork-github>
